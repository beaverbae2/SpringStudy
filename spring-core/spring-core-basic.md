# 스프링 기본 원리 - 기본편



## 좋은 객체 지향 프로그래밍이란

### 다형성

> 역할과 구현의 구분, **유연하고 변경에 용이한 코드 구현**

- 비유
  - 운전자 - 자동차
    - 운전자는 자동차의 종류가 바뀌어도 운전을 할 수 있어야함
    - 운전자는 자동차의 역할만 알고 있으면 됌
    - 자동차의 종류를 무한히 확장할 수 있음
    - **운전자에게 영향을 주지 않고**, 자동차의 종류를 바꿀 수 있음
- 역할과 구현의 분리
  - 클라이언트는 대상의 역할(인터페이스)만 인지하면 됌
  - 클라이언트는 구현 대상의 내부 구조 몰라도 괜찮음
  - 클라어언트는 구현 대상의 내부 구조 변경되도 영향 없음
  - 클라이언트는 구현 대상을 변경해도 영향 없음
- 자바
  - 역할 : 인터페이스, 구현 : 인터페이스를 구현한 클래스
  - 설계 시 인터페이스를 먼저 작성 -> 안정적인 설계 필요
  - 오버라이딩
    - 다형성의 구현
    - 구현 객체의 메소드가 실행
    - 런타임 시, 구현 객체 선택 (**유연하게 변경**)
- 본질
  - 객체 지향 : 객체 사이의 **협력 관계** (클라이언트 - 서버)
  - **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경**
  - 런타임 시, 인터페이스를 구현 객체로 유연하게 변경

<br><br>

## SOLID

요약 : 다형성만으로 OCP, DIP를 지킬 수 없음 -> 구현 객체 변경 시 클라이언트 코드도 변경

목적 : 변경 최소화

### SRP - Single Responsibility Principle

> 단일 책임 원칙, 한 클래스는 하나의 책임만 가져야 함

기준 : **변경**

-> 변경이 발생했을 때, 파급효과가 적어야 함 (이상적으로, 하나의 클래스의 한 지점만 수정)

### OCP - Open Close Principle

> 개방 폐쇄 원칙, 소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 함

다형성만으로 OCP를 지킬 수 없음 -> 구현 객체(`MemberRepository`) 변경 시, 클라이언트(`MemberService`) 코드 변경 발생

```java
public class MemberService {
  //private MemberRepository memberRepository = new MemoryMemberRepository();
  private MemberRespository memberRepository = new JdbcMemberRepository(); 
}
```

무언가 더 필요하다...!

### LSP - Liscov Substitution Principle

> 리스코프 치환 원칙, 프로그램은 객체의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함

인터페이스를 구현한 하위 클래스는 인터페이스의 규약을 지켜야 함

- 규약
  - **인터페이스에서 의도한 기능**
  - ex) 자동차의 엑셀 : 앞으로 가야함, 뒤로가면 LSP 위반

### ISP - Interface Segregation Principle

> 인터페이스 분리 원칙, 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 나음

Ex) 자동차

- 클라이언트: 운전자, 정비사
- 서버 : 운전 인터페이스, 정비 인터페이스
- **클라이언트의 담당 외 서버 인터페이스가 변해도 영향없음** (정비 인터페이스가 변해도 운전자 클라이언트에 영향 없음)

### DIP - Dependency Inversion Principle

> 의존 관게 역전 원칙, 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안됌

클라이언트는 구현 클래스가 아닌, 인터페이스에 의존 -> 역할에 의존, **유연하게 구현 객체를 변경하기 위함**

다형성 만으로 DIP 지킬 수 없음 -> 추상화(인터페이스), 구체화(구현 객체) 모두에 의존 (**클라이언트가 직접 구현 객체 선택**)

```java
public class MemberService {
  //private MemberRepository memberRepository = new MemoryMemberRepository();
  private MemberRespository memberRepository = new JdbcMemberRepository(); 
}
```

무언가 더 필요하다...!
<br>
<br>
## 객체 지향 설계와 스프링

### DI 컨테이너(스프링 컨테이너)

- 다형성 + OCP, DIP 구현 가능

### 실무 고민

- 인터페이스 : 추상화 비용 발생
- 기능을 확장할 가능성이 없을 때 구체클래스 사용

<br>
<br>

## 스프링 핵심 원리 이해1 - 예제 만들기

### 프로젝트 생성

링크 : start.spring.io

생성 방법

- Project : gradle
- Spring Boot : SNAPSHOT 아닌것들
- Java : 11

<br>
<br>

### 비즈니스 요구 사항 및 설계

회원

- 행동 : 가입, 조회
- 등급 : 일반, VIP
- **DB : 자체 or 외부 (미정)**

주문과 할인정책

- 회원은 주문을 함
- 할인 
  - 등급에 따라 정해짐
  - 정액 할인 : VIP만 1000원 할인
  - **변경 가능 (미정)**

<br>
<br>

### 회원 도메인 설계

- 도메인 협력 관계
  - 각 도메인들간의 관계 : 의존, 상속, ..
  - 기획자와 개발자 모두 이해 가능
- 클래스 다이어그램
  - 도메인 협력 관계를 통해 코드로 구현한 클래스들 간의 관계 표시 (<u>정적</u>)
  - 개발자용
- 객체 다이어그램
  - 런타임 시 실제 클래스 다이어그램에서 어떤 객체가 선택되는지 (<u>동적</u>)

<br>
<br>

### 회원 도메인 설계의 문제점

OCP, DIP 위배

- 다른 저장소로 저장 시 코드 변경 발생
- 추상화와 구체와 모두에 의존

<br>
<br>

### 주문과 할인 도메인 설계

- 회원은 상품 주문을 함
- 회원 등급에 따라 할인 정책 적용
  - VIP만 1000원 할인
  - 할인 정책은 변경될 수 있음
- 주문 도메인 전체
  - 화원 저장소 -> 인터페이스
    - 인메모리
    - DB
  - 할인 정책 -> 인터페이스
    - 정액 할인
    - 정률 할인
- 클래스 다이어그램, 객체 다이어그램
  - 협력 관계 재사용 가능 -> 주문 서비스를 변경하지 않고, 회원 저장소와 할인 정책을 유연하게 변경 가능

<br>
<br>

## 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

### 새로운 할인 정책 개발

- 정률 할인 정책으로 변경 : 10% 할인

<br>
<br>

### 새로운 할인 정책 문제점

- 할인 정책 변경 시 클라이언트인 `OrderServiceImpl` 수정 필요

  - OCP 위배 : 할인 정책 변경 시, 코드 변경 발생

  - DIP 위배 :  `OrderServiceImpl` 이 `DiscountPolicy` (추상)와 `FixDiscountPolicy` (구체) 모두에 의존

- 해결 방법

  - 클라이언트가 인터페이스에만 의존하게 하기
    - `OrderServiceImpl`이 `DiscountPolicy`에만 의존하게 함
    - 구현체가 없어서 실행 못함 (`NPE`)

<br>
<br>

### 관심사의 분리

- 비유
  - 로미오와 줄리엣
    - 로미오 역인 디카프리오는 줄리엣 역이 누구냐에 상관 없이 배역 수행
    - 관심사의 분리
      - 배우는 연기만 하면 되지, 상대 배역을 선택할 필요 없음 
      - 섭외는 공연 기획자의 역할
- `OrderServiceImpl` 문제점
  - 구체적인 할인 정책을 **직접** 선택함
  - 관심사의 분리 필요 -> 객체를 생성하여 연결해주는 별도 설정자 필요
- `AppConfig`
  - 객체를 생성해주고 관계를 만들어주는 별도 설정자
  - 생성자 주입을 활용하여 `MemberServiceImpl` 과 `OrderServiceImpl` 에 필요한 의존관계 주입(DI)
  - `MemberServiceImpl` 과 `OrderServiceImpl` 입장에서는 구체적으로 어떤 객체가 주입되는지 모름, 단지 어떤 역할을 하는지만 알음 (DIP)

<br>
<br>

### AppConfig 리팩토링

- 역할과 구현이 한 눈에 드러나게 리팩토링

<br>
<br>

### 새로운 구조와 할인 정책 적용

- 할인 정책 변경 시
  - `AppConfig` 만 수정하면 됌.
  - **구성 영역만 수정하면 되고, 사용 영역(클라이언트)은 수정할 필요 없음**
- 기존에 언급한 OCP, DIP 의 적용범위는 사용 영역 기준
  - 구성 영역은 적용 대상 아님

- 결과 : OCP, DIP 지킴

<br>
<br>

### 정리

할인 정책 추가 개발

- 다형성을 활용하여 개발 -> 이상 없음

새로운 할인 정책 적용과 문제점

- 새로운 할인 정책 적용시 클라이언트 영역에서 직접 주문 서비스 구현체를 변경해야 함
- DIP 위반 : 클라이언트인 `OrderServiceImpl`은  인터페이스인 `DiscountPolicy` 와 구현체인 `RateDiscountPolicy` 에 모든 의존

관심사의 분리

- 어플리케이션의 구조 나누기 -> 책임 분리 (SRP)
  - 사용 영역 : 비즈니스 로직 수행
  - 구성 영역 : 어플리케이션 전반에 필요한 객체를 생성하고 의존 관계를 맺어주는 역할

`AppConfig` 리팩토링

- 구성 영역의 역할과 구현을 명확히 분리
- 중복 제거

 새로운 구조와 할인 정책 적용

- 할인 정책 변경시, 사용 영역은 수정할 필요없음, 구성 영역만 변경

<br>
<br>

### 좋은 객체 지향 설계의 5가지 원칙의 적용

SRP

- 한 클래스는 하나의 책임만 가져야 한다
- - 관심사의 분리
    - 사용 영역(`OrderServiceImpl`)
    - 구성 영역(`AppConfig`)

DIP

- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다
- 관심사의 분리
  - 사용 영역(`OrderServiceImpl`) : 인터페이스(`DiscountPolicy`)에만 의존
  - 구성 영역(`AppConfig`) : 구현 객체(`FixDiscountPolicy`) 생성 및 의존 관계 주입

OCP

- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있다
- 할인 정책 변경시 구성영역만 변경해주면 되고, 사용 영역은 변경할 필요 없음

<br>
<br>

### IoC, DI 그리고 컨테이너

IoC(Inversion of Control) - 제어의 역전

- 프로그램의 제어 흐름을 외부에서 가지는 것
- 제어 : 객체를 생성하고 연관 관계를 맺어 주는 것 -> `AppConfig`

 프레임워크 vs 라이브러리

- 프레임워크 : 내가 작성한 코드를 프레임워크가 제어 -> JUnit
- 라이브러리 : 내가 작성한 코드로 직접 제어 

DI(Dependency Injection) - 의존 관계 주입

- **정적인 클래스 의존 관계와 실행시점에 결정되는 동적인 객체 의존 관계를 분리 해서 접근**
  - 정적 : 클래스 다이어그램
    - `OrderServiceImpl` 은 `MemberRepository` , `DiscountPolicy`에 의존 -> 실제로 어떤 객체가 주입되는지는 알 수 없음
  - 동적 : 객체 다이어그램
    - 의존 관계 주입 : 어플리케이션 실행 시점에 외부에서 구현 객체를 생성하고, 이를 클라이언트로 전달하여, 서버와 클라이언트 간 의존 관계가 성립 되는 것
  -  DI를 사용하면 정적인 클래스 의존 관계는 변경하지 않고(어플리케이션 코드를 수정하지 않고), 동적인 객체 의존 관계를 쉽게 변경

IoC컨테이너, DI컨테이너

- 객체를 생성하고 의존 관계를 연결

<br>
<br>


